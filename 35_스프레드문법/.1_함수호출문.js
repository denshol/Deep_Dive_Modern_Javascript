/**
 * ES6에서 도입된 스프레드문법(전개문법) ...은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서(전개,분산하여,spread) 개별적인 값들의 목록으로 만든다.
 * 
 * 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection),arguments와 같이 for...of문으로 순회 할 수 있는 이터러블에 한정된다
 * 
 * 
 */

// 예제 35-01
// ...[1,2,3]은 [1,2,3]을 개별적인 값으로 분리한다.
console.log(...[1,2,3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(..."Hello"); // H e l l o

// Map과 Set은 이터러블이다.
console.log(...new Map([['a', '1'], ['b', '2']])); // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1,2,3])); // 1 2 3

// DOM 컬렉션은 이터러블이다.
console.log(...document.querySelectorAll('p')); // <p>...</p> <p>...</p> <p>...</p>

// arguments 객체는 이터러블이다.
(function() {
  console.log(...arguments); // 1 2 3
})(1,2,3);

//이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{a:1, b:2}); // TypeError: Found non-callable @@iterator

/*
위 예제에서 ...[1,2,3]은 이터러블인 배열을 펼쳐서 요소들을 개별적인 값들의 목록 1 2 3 으로 만든다
이때 1 2 3은 값이 아니라 값들의 목록이다. 
즉, 스프레드 문법의 결과는 값이 아니다. 이는 스프레드 문법...이 피연산자를 연산하여 값을 생성하는 연산자가 아님을 의미한다 따라서 스프레드 문법의 결과는 변수에 할당할 수 없다.
*/

// 예제 35-02
// 스프레드 문법의 결과는 값이 아니라 값들의 목록이다.
const spreadObj = ...[1,2,3]; // SyntaxError: Unexpected token '...'
const spreadObj = [...[1,2,3]]; // [1,2,3]

//이처럼 스프레드 문법의 결과물은 값으로 사용할 수 없고, 다음과 같이 쉼표로 구분한 값의 목록을 사용하는 문맥에서 사용해야 한다.

// 함수 호출문의 인수 목록,
// 배열 리터럴의 요소 목록,
// 객체 리터럴의 프로퍼티 목록,

// 35.1 함수 호출문의 인수 목록에서 사용하는 경우
/**
 * 요소들의 집합인 배열을 펼쳐서 개별적인 값들의 목록으로 만든후, 이를 함수의 인수 목록으로 전달해야 하는 경우가 있다 다음예제를 살펴보자
 * 
 */

// 예제 35-03
const arr = [1,2,3];

// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max 함수를 호출한다.

const max = Math.max(arr); // NaN

//Math.max 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수다. 다음과 같이 개수가 정해져 있지 않은 여러개의 숫자를 인수로 전달받아 인수 중에서 최대값을 console.error('반환한다',반환한다)


// 예제 35-04
Math.max(1); // 1
Math.max(1,2); // 2
Math.max(1,2,3); // 3
Math.max(); // -Infinity
//만약 Math.max 함수에 배열을 인수로 전달하면 NaN을 반환한다. 이는 Math.max 함수가 인수로 전달받은 배열을 펼쳐서 개별적인 숫자로 인식하기 때문이다.

// 예제 35-05
Math.max([1,2,3]); // NaN
/**
 * 이 같은 문제를 해결하기 위해 배열을 펼쳐서 요소들을 개별적인 값들의 목록으로 만든 후,Math.max 메서드의 인수로 전달해야 한다. 즉 [1,2,3]을 1,2,3으로 펼쳐서 Math.max 메서드의 인수로 전달해야 한다.
 * 
 * 스프레드 문법이 제공되기 이전에는 배열을 펼쳐서 요소들의 목록을 함수의 인수로 전달하고 싶은 경우 Function.prototype.apply 메서드를 사용했다.
 * 
 * 
 */

// 예제 35-06
var arr = [1,2,3];

 // apply 함수의 2번째 인수(배열) apply함수가 호출하는 함수의 인수 목록이다

 //따라서 배열이 펼쳐져서 인수로 전달되는 효과가 있다.

 var max = Math.max.apply(null, arr); // 3

// ES6에서는 스프레드 문법을 사용하여 배열을 펼쳐서 요소들의 목록을 함수의 인수로 전달할 수 있다. 더 간결하고 가독성이좋다.

// 예제 35-07
const arr = [1,2,3];

// 스프레드 문법을 사용하여 배열 arr을 펼쳐서 Math.max 함수의 인수로 전달한다.
//Math.max(...[1,2,3])은 Math.max(1,2,3)과 동일하게 동작한다.
const max = Math.max(...arr); // 3

/**
 *  스프레드 문법은 앞에서 살펴본 REst파라미터와 형태가 동일하여 혼동할 수 있으므로 주의할 필요가 있다.
 * 
 * Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 ...을 붙이는 것이고, 스프레드 문법은 여러개의 값이 하나로 뭉쳐있는 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록으로 만드는 것이다.
 * 따라서 Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다.
 * 
 */

// 예제 35-08
// Rest 파라미터는 인수들의 목록을 배열로 전달받는다.
function foo(...rest) {
  // rest는 배열이다.
  console.log(Array.isArray(rest)); // true
  console.log(rest); // [ 1, 2, 3, 4, 5 ]
}

//스프레드 문법은 배열과 같은 이터러블을 펼처서 개별적인 값들의 목록을 만든다.
// [1,2,3,4,5]는 1,2,3,4,5로 펼쳐진다.
foo(...[1,2,3,4,5]);


//35.2 배열 리터럴의 요소 목록에서 사용하는 경우
/**
 *  스프레드 문법을 배열리터럴에서 사용하면 ES5에서 사용하던 기존의 방식(apply 메서드를 사용하는 방식)보다 간편하게 배열을 복사할 수 있다.
 * 
 */

//35.2.1 concat
//ES5에서 2개의 배열을 1개의 배열로 결합하고 싶은 경우 배열 리터럴만으로 해결할수없고 concat 메서드를 사용해야 한다.

// 예제 35-09
// ES5
var arr1 = [1,2].concat([3,4]);
console.log(arr1); // [1,2,3,4]
//ES6에서는 스프레드 문법을 사용하여 배열을 펼쳐서 요소들의 목록으로 만든 후, 이를 배열 리터럴 내부에서 사용하면 배열을 복사할 수 있다.

// 예제 35-10
// ES6
const arr2 = [...[1,2], ...[3,4]];
console.log(arr2); // [1,2,3,4]

//35.2.2 push
//ES5에서 배열의 끝에 1개 이상의 요소를 추가하려면 push 메서드를 사용한다.

// 예제 35-11
// ES5
var arr1 = [1,2];
var arr2 = [3,4];

Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1,2,3,4]

//ES6에서는 스프레드 문법을 사용하여 배열을 펼쳐서 요소들의 목록으로 만든 후, 이를 배열 리터럴 내부에서 사용하면 배열의 끝에 1개 이상의 요소를 추가할 수 있다.

// 예제 35-12
// ES6
const arr1 = [1,2];
const arr2 = [3,4];

arr1.push(...arr2);
console.log(arr1); // [1,2,3,4]
 
//35.2.3 splice
 
//ES5에서 배열의 특정 위치에 1개 이상의 요소를 추가하려면 splice 메서드를 사용한다.

// 예제 35-13
// ES5
var arr = [1,4];
Array.prototype.splice.apply(arr, [1,0].concat([2,3]));
console.log(arr); // [1,2,3,4]
 
 
//ES6에서는 스프레드 문법을 사용하여 배열을 펼쳐서 요소들의 목록으로 만든 후, 이를 배열 리터럴 내부에서 사용하면 배열의 특정 위치에 1개 이상의 요소를 추가할 수 있다.

// 예제 35-14
// ES6
const arr = [1,4];
arr.splice(1,0,...[2,3]);
console.log(arr); // [1,2,3,4]

//35.2.4 unshift
//ES5에서 배열의 시작점에 1개 이상의 요소를 추가하려면 unshift 메서드를 사용한다.

// 예제 35-15
// ES5
var arr = [4,5,6];
Array.prototype.unshift.apply(arr, [1,2,3]);
console.log(arr); // [1,2,3,4,5,6]

 
//ES6에서는 스프레드 문법을 사용하여 배열을 펼쳐서 요소들의 목록으로 만든 후, 이를 배열 리터럴 내부에서 사용하면 배열의 시작점에 1개 이상의 요소를 추가할 수 있다.

// 예제 35-16
// ES6
const arr = [4,5,6];
arr.unshift(...[1,2,3]);
console.log(arr); // [1,2,3,4,5,6]


//35.2.6 concatAll
//ES5에서 2차원 배열을 1차원 배열로 변환하려면 concat 메서드를 사용한다.

// 예제 35-19
// ES5
var arr = [[1,2],[3,4],[5,6]];

// concat 메서드는 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환한다.
var flattened = arr.concat();
console.log(flattened); // [1,2,3,4,5,6]

//ES6에서는 스프레드 문법을 사용하여 배열을 펼쳐서 요소들의 목록으로 만든 후, 이를 배열 리터럴 내부에서 사용하면 2차원 배열을 1차원 배열로 변환할 수 있다.

// 예제 35-20

// ES6
const arr = [[1,2],[3,4],[5,6]];

// 스프레드 문법은 배열을 펼쳐서 요소들의 목록으로 만든다.
const flattened = [].concat(...arr);

console.log(flattened); // [1,2,3,4,5,6]






// 35.3 객체 리터럴의 프로퍼티 목록에서 사용하는 경우
/**
 * Rest 프로퍼티와 함께 2021년 1월 현재 TC39 프로세스의 stage4에 제안되어 있는 스프레드 프로퍼티를 사용하면 객체 리터럴의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다.
 * 스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다.
 * 
 * 
 */

 // 예제 35-09
  // 스프레드 프로퍼티 제안은 객체 리터럴의 프로퍼티 목록에서 스프레드 문법을 사용할 수 있게 한다.

  //객체 복사(얕은 복사)
  const obj = { x:1, y:2 };
  const copy = { ...obj };
  console.log(copy); // { x: 1, y: 2 }
   console.log(obj === copy); // false
 
  // 객체 병합
  const merged = { x:1, y:2, ...{ a:3, b:4 } };
  console.log(merged); // { x: 1, y: 2, a: 3, b: 4 }  


//스프레드 프로퍼티가 제안되기 이전에는 ES6에서 도입된 Object.assign 메서드를 사용하여 여러개의 객체를 병합하거나 복사했다. 특정 프로퍼티를 변경y하거나 추가했다.

// 예제 35-10
// 객체 병합
const merged = Object.assign({ x:1, y:2 }, { y:10, z:3 });
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = Object.assign({ x:1, y:2 }, { y:100 });
console.log(changed); // { x: 1, y: 100 }

// 특정 프로퍼티 추가
const added = Object.assign({ x:1, y:2 }, { z:0 });
console.log(added); // { x: 1, y: 2, z: 0 }

// 스프레트 프로퍼티는 Object.assign 메서드를 대체할 수 있는 간편한 문법이다.

// 예제 35-11
// 객체 병합 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = { x:1, y:2, ...{ y:10, z:3 } };
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { x:1, y:2, ...{ y:100 } };
console.log(changed); // { x: 1, y: 100 }

// 특정 프로퍼티 추가
const added = { x:1, y:2, ...{ z:0 } };
console.log(added); // { x: 1, y: 2, z: 0 }





   























